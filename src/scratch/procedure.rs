use json::{object, JsonValue};
use crate::scratch::expr_idx_to_id;
use super::{block::parse_block, Statement};

/// Represents a procedure in scratch
#[derive(Debug)]
pub struct Procedure {
    pub ident: String,
    pub body: Vec<Statement>,
}

/// Parses a procedure call and outputs the generated json
pub(super) fn call_procedure(procedure_ident: &str) -> JsonValue {
    object! {
        opcode: "procedures_call",
        inputs: {},
        fields: {},
        mutation: {
            tagName: "mutation",
            children: [],
            proccode: procedure_ident,
            argumentids: "[]",
            warp: "false",
        },
    }
}

/// Adds a procedure definition to the scratch json generated by [`assemble`](crate::scratch::assembler::assemble)
pub(super) fn parse_procedure(procedure: Procedure, expr_blocks: &mut Vec<JsonValue>) {
    // append the body of the procedure and get the id
    let id = parse_block(procedure.body, expr_blocks);

    expr_blocks.push(object! { // information about the procedure (excluded from execution chain)
        opcode: "procedures_prototype",
        next: null,
        parent: null,
        input: {},
        fields: {},
        shadow: true,
        topLevel: false,
        mutation: {
            tagName: "mutation",
            children: [],
            proccode: &*procedure.ident,
            argumentids: "[]",
            argumentnames: "[]",
            argumentdefaults: "[]",
            warp: "false",
        },
    });
    
    // insert the start block of the procedure
    expr_blocks.push(object! { // the start of the execution chain for this procedure
        opcode: "procedures_definition",
        next: id,
        parent: null,
        inputs: {
            custom_block: [
                1,
                expr_idx_to_id(expr_blocks.len()-1), // was pushed before this block
            ]
        },
        fields: {},
        shadow: false,
        topLevel: true,
        x: 0,
        y: 0,
    });
}
