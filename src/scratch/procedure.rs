use json::{object, JsonValue::{self, Null}};
use crate::scratch::expr_idx_to_id;

use super::{parse_stmt, Statement};

pub struct Procedure<'a> {
    pub ident: String,
    pub body: &'a [Statement],
}

/// Parses a procedure call and outputs the generated json
pub(super) fn call_procedure(procedure_ident: &str) -> JsonValue {
    object! {
        opcode: "procedures_call",
        inputs: {},
        fields: {},
        mutation: {
            tagName: "mutation",
            children: [],
            proccode: procedure_ident,
            argumentids: "[]",
            warp: "false",
        },
    }
}

/// Adds a procedure definition to the scratch json generated by [`assemble`](crate::scratch::assembler::assemble)
pub(super) fn parse_procedure(procedure: &Procedure, expr_blocks: &mut Vec<JsonValue>) {
    let stmt_blocks = procedure.body.iter()
        .map(|stmt| parse_stmt(stmt, expr_blocks))
        .collect::<Vec<_>>();
    
    expr_blocks.push(object! { // information about the procedure (excluded from execution chain)
        opcode: "procedures_prototype",
        next: null,
        parent: null,
        input: {},
        fields: {},
        shadow: true,
        topLevel: false,
        mutation: {
            tagName: "mutation",
            children: [],
            proccode: &*procedure.ident,
            argumentids: "[]",
            argumentnames: "[]",
            argumentdefaults: "[]",
            warp: "false",
        },
    });
    
    // insert the start block of the procedure
    expr_blocks.push(object! { // the start of the execution chain for this procedure
        opcode: "procedures_definition",
        next: expr_idx_to_id(expr_blocks.len()+1), // block after this one
        parent: null,
        inputs: {
            custom_block: [
                1,
                expr_idx_to_id(expr_blocks.len()-1), // was pushed before this block
            ]
        },
        fields: {},
        shadow: false,
        topLevel: true,
        x: 0,
        y: 0,
    });

    // insert the statement blocks
    let stmt_blocks_len = stmt_blocks.len();
    for (i, mut stmt_block) in stmt_blocks.into_iter().enumerate() {
        let idx = expr_blocks.len(); // true block index with expr blocks as an offset

        // update the link to the next block (if there is one)
        if i == stmt_blocks_len-1 { // last block shouldn't have a 'next' field
            stmt_block["next"] = Null;
        } else {
            stmt_block["next"] = expr_idx_to_id(idx+1).into();
        }

        // set other builderplate fields
        stmt_block["shadow"] = false.into();
        stmt_block["topLevel"] = false.into();
        stmt_block["parent"] = Null;

        expr_blocks.push(stmt_block);
    }
}
